**JRE=JVM+类库**
**JDK=JRE+Java开发工具**
##书写规范
1. 左大括号前有空格
2. 方法和程序块之间加空行隔开
3. 并排语句之间加空格，例如for语句
4. 运算符两侧加空格

**配置环境变量后，能够在任何目录下使用javac命令**
**java关键字全是小写**

##命名规则
**包名命名**

1. 全部小写
2. 域名倒着写

**类、几口命名**

1. 每个单词首字母大写（驼峰命名）

**方法**

1. 第一个单词首字母小写，后面单词的首字母大写

**常量**

1. 一个单词，所有字母大写
2. 多个单词，所有单词的字母大写，单词之间加_

##进制

* 二进制
	* 以0b或0B 开头
* 八进制
	* 以0开头
* 十六进制
	* 0x开头 

**10进制转X进制**
*每个系数乘基数的权次幂再相加*


**X进制转10进制**
*除积倒着去余数*

##原反补
* 原码
	* 最高位是符号位，0正1负，其余位数表示数字大小
* 反码
	* 正数原反补相同；负数的反码是，对其除了符号位外，逐位取反
* 补码
	* 正数的原反补相同；负数的补码实将其反码的末位加1

##变量
* 局部变量在使用之前必须赋值

* 数据类型转换
	* 隐式转换――――当大的数据类型和小的数据类型在一起运算时，小的数据类型会自动提升为大的数据类  型
	* 强制类型转换――――如果超出被赋值的数据类型的取值范围，则得到的结果会与期望的结果不同。向下                  强制类型转换会损失精度。


* byte与byte（或short，char）进行运算时会提升为int
* 在编译时，无法判断变量的值，有可能超出byte的范围 （如下例）

	byte b1 = 3;
	byte b2 = 4;
	byte b3 = b1 + b2;   （报错）
	
**进行混合运算时，byte、short、char不会相互转换，而是自动类型转换为int型，其他类型进行混合预算时，是小的数据类型提升为大的数据类型**

|**      |**       |**		|**		|**		   |**	  |**   	|**    | **   |
|--------|:------:|:-----:|:----:|:-------:|:-----:|:------:|:-----:|:----:|
|byte	|           |       |		|		  |		  |   	   |  		|	  |
|short  |---------->|int	|------>|long	|------->|float		|----->|double|      
|char   |			|		|		 |		|		 |			|   	|		|
	

**float的取值范围大于long**

**任何数据类型直接用 + 与字符串相连都会产生新的字符串**

		System.out.println("hello"+'a'+1);    
		生成字符串  helloa1

		System.out.println('a'+1+"hello");
		从左往右运算，'a' + 1 =98,然后，98 + “hello” 
		生成字符串  98hello

**byte 范围：-128~127**
**char 范围：0~65535**
**char 可以存储中文**
>     原因：java使用Unicode编码。
>     	   在Unicode编码中，每个字节占2byte。
>	  	   而中文的一个汉字在内存中也占2byte，故可以。	

##运算符

**整数和整数相除只能得到整数。若想得到小数，把其中一个数变成小数，另一个数在运算时会自动类型提升**

* 取余 % 
	* 当左边的绝对值小于右边的绝对值时，结果为左边本身
	* 当左边的绝对值等于右边或是右边的的倍数时，结果是0
	* 当左边的绝对值大于右边的绝对值时，结果是余数
	* % 运算符结果的符号和左边的数的符号保持一致，与右边数无关
	* 任何一个正整数 % 2 后，结果不是 0 就是 1 ，（可用来最为切换条件）

* 自增自减   ++
	* 当++在变量后面时，会现将变量中的值取出，做赋值操作，然后在自身+ 1 
		b = a++;
	* 当++ 在变量前面时，会先自身+1，然后再将+1后的结果赋值
		b = ++ a ;
* +=


			void test(){
				short s = 1;
				s +=1;   //底层进行  s = (short)(s + 1);
			----------------------------------
				short s = 1;
				//等号右边的1位int型
			    //short与int相加时，short会自动提升为int
				//int赋值给short会损失精度，即报错
				s = s + 1;

			}

* &&和& 的区别
	* &&具有短路效果，左边是false，右边就不执行
* || 与 | 的区别
	* || 具有短路效果，左边为true，右边不执行
* 位运算符
	* 按位与 &
	* 按位或 |
	* 按位异或 ^
		* 一个整数对另一个整数异或2次，该数本身不变(用于交换两个整数)
	* 按位取反 ~
	* 移动（左乘右除）
		* 左移――――向左移动几位就是乘以2的几次方
			* 左边最高位丢弃，右边补0
		* 右移――――向右移动几位就是除以2的几次方
			* 有符号右移	>>
				* 最高位是0，左边补0；最高位是1，左边补1
			* 无符号右移	>>>
				* 左边只补0
* 键盘输入  Scanner

<hr/>

							System.out.println(6 & 3 );
							/*
								6	110
								3	011
	    						&			按位与
	    						---------
									010     等于2
							*/
					
							System.out.println( 6 | 3);
							/*
								6	110
								3	011
								|			按位或
								---------
							        111     等于7
							*/
							System.out.println(6 ^ 3);
							/*
								6	110
								3	011
	
								^			按位异或
								---------
								    101     等于5
							*/
	
			
		System.out.println(~6);			//取反	~  	//包括符号位在内，逐位取反
		/*
		6为正数，原反补相同
		在运算时，使用的是补码
			6	00000000 00000000 00000000 00000110		然后逐位取反
	
			    11111111 11111111 11111111 11111001		此为补码，再算反码
	  		  - 00000000 00000000 00000000 00000001
	        ----------------------------------------
				11111111 11111111 11111111 11111000		得到反码，除符号位外，逐位取反
				10000000 00000000 00000000 00000111		得到原码，即为 -7
	
		*/
		/*
			通过按位异或交换两个整数
			x = x ^ y;		//x = 10 ^ 5
			y = x ^ y;		//y = 10 ^ 5 ^ 5 = 10
			x = x ^ y;		//x = 10 ^ 5 ^ 10 = 5
		*/
		/*	
				System.out.println(12 << 1);
				System.out.println(12 << 2);
   
				12为正数，原反补相同，运算时用补码
				00000000 00000000 00000000 00001100		12的补码
				12向左移动1位,末尾补0
			 (0)0000000 00000000 00000000 000011000		24的补码
				12向左移动2位，末尾补0
			(00)000000 00000000 00000000 0000110000		48的补码
		*/
		/*
				System.out.println(12 >> 1);
				System.out.println(12 >> 2);
				12为正数，原反补相同，运算时用补码
				00000000 00000000 00000000 00001100		12的补码
				12,有符号右移，移动1位，最高位为0，右边补0
				00000000 00000000 00000000 00000110(0)	6的补码
				12,有符号右移，移动2位，最高位为0，右边补0
				00000000 00000000 00000000 00000011(00)	3的补码

		*/


		/*
			1.输入两个整数判断是否相等
			2.输入三个整数获取最大值
		*/
		import java.util.Scanner;     //导包
		
		class Test2_Scanner {
			public static void main(String[] args) {
				//创建键盘输入对象
				Scanner sc = new Scanner(System.in);
				System.out.println("输入第一个数：");
				//将键盘输入的整数存入x
				int x = sc.nextInt();
				System.out.println("输入第二个数：");
				//将键盘输入的整数存入y
				int y = sc.nextInt();
				System.out.println("x 与 y 相等吗？\t" + (x == y));
				System.out.println("输入第三个数：");
				//将键盘输入的整数存入z
				int z = sc.nextInt();
				int temp = (x > y) ? x : y;
				int max = (z > temp) ? z : temp;
				System.out.println(x+"\t"+ y+"\t"+z+"\t三个整数中最大的为\t"+max	);
			}
		}


##流程控制
 
 * if 和三元运算符的区别 
 	* 三元运算符能实现的，if语句都能实现，反之不行
 	* 当if语句控制的操作是一个输出语句时，只能用if，不能用三元运算符。因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。 
 * switch（表达式）
 	* 表达式可以是
 		* 基本数据类型：byte、short、char、int
 		* 引用数据类型：枚举类（JDK 1.5）、String 类（JDK 1.7）
	* case 后边只能是常量，不能使变量，多个case后面的值不能出现相同的
	* break 一般不能省略，省略后会出现 case穿透
	* default 无论放哪都是最后执行，一般放在最后
	* switch 结束只有2种情况
		* 遇到break
		* 遇到switch结束的右大括号
* switch 和 if 各自的使用场景
	* switch――――判断固定值时使用
	* if――――判断区间或范围的使用

			
				/*
					x = 2 没有与case匹配上，所以执行default
					default中没有break，所以继续执行default后面的case语句
					而后面的case语句中都没有break
					所以直到遇到switch结束的大括号停止
				*/
					int x = 2;
					int y = 3;
					switch (x) {
						default :
							y++;
						case 3:
							y++;
						case 4:
							y++;
					}
					System.out.println("y = "+y);     // y = 6

* 转义字符

	|			|			|
	|-----------|:---------:|
	|**\t**     | 一个tab键的位置|
	|**\r** 	|回车		|
	|**\n**		|换行		|
	|**\\'**		|  '  单引号|
	|**\\"**		|  "  双引号|


##数组

		int[] arr = new int[5];
		System.out.println(arr[0]);   //系统给出默认初始化值 ，整数类型的都是0
		System.out.println(arr);	  //   输出   [I@2a139a55
		/*
			[I@2a139a55  解释

			[	代表数组，几个就代表几维
			I	代表int型
			@	固定的符号
			2a139a55	代表的是16进制的地址

		*/

|	**	|	**          	    |默认初始化值|
|-------|:---------------------:|:----------:|
|整数类型|byte、short、int、long|0           |
|浮点类型|float、double         |0.0         |
|布尔类型|boolean               | false      |
|字符类型|char                  | \u0000     |

>	char 在内存中占2byte，是16个二进制位
						\u0000  中的每一个0代表的是16进制的0，那么4个0代表16个二进制位



